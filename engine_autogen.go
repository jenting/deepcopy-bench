package types

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Snapshot) DeepCopyInto(out *Snapshot) {
	*out = *in
	if in.Children != nil {
		in, out := &in.Children, &out.Children
		*out = make(map[string]bool, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	return
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EngineStatus) DeepCopyIntoAuto(out *EngineStatus) {
	*out = *in
	out.InstanceStatus = in.InstanceStatus
	if in.CurrentReplicaAddressMap != nil {
		in, out := &in.CurrentReplicaAddressMap, &out.CurrentReplicaAddressMap
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ReplicaModeMap != nil {
		in, out := &in.ReplicaModeMap, &out.ReplicaModeMap
		*out = make(map[string]ReplicaMode, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.BackupStatus != nil {
		in, out := &in.BackupStatus, &out.BackupStatus
		*out = make(map[string]*BackupStatus, len(*in))
		for key, val := range *in {
			var outVal *BackupStatus
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(BackupStatus)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RestoreStatus != nil {
		in, out := &in.RestoreStatus, &out.RestoreStatus
		*out = make(map[string]*RestoreStatus, len(*in))
		for key, val := range *in {
			var outVal *RestoreStatus
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(RestoreStatus)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.PurgeStatus != nil {
		in, out := &in.PurgeStatus, &out.PurgeStatus
		*out = make(map[string]*PurgeStatus, len(*in))
		for key, val := range *in {
			var outVal *PurgeStatus
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(PurgeStatus)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.RebuildStatus != nil {
		in, out := &in.RebuildStatus, &out.RebuildStatus
		*out = make(map[string]*RebuildStatus, len(*in))
		for key, val := range *in {
			var outVal *RebuildStatus
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(RebuildStatus)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.CloneStatus != nil {
		in, out := &in.CloneStatus, &out.CloneStatus
		*out = make(map[string]*SnapshotCloneStatus, len(*in))
		for key, val := range *in {
			var outVal *SnapshotCloneStatus
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(SnapshotCloneStatus)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Snapshots != nil {
		in, out := &in.Snapshots, &out.Snapshots
		*out = make(map[string]*Snapshot, len(*in))
		for key, val := range *in {
			var outVal *Snapshot
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = new(Snapshot)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	return
}
